# Authorization Server - Dynamic Client Registration

## Description
Introduce the initial slice of the authorization server: a standards-compliant Dynamic Client Registration (DCR) capability. This feature creates the foundation for future authorization and token issuance work and must align with the Model Context Protocol (MCP) specification referenced in `docs/`. All backend implementation must follow the conventions in `docs/best-practices` and `docs/how-to-guides` (especially module structuring, DTO layering, validation, and persistence patterns).

## Workflow
1. An API client submits a registration request to the authorization server DCR endpoint.
2. The system validates the payload against the OAuth 2.0 Dynamic Client Registration specification (RFC 7591 & 7592), the MCP requirements, and our security constraints.
3. A new client entity is persisted in the database and the response returns the generated client credentials & metadata.
4. Administrators can query or manage registered clients through follow-up endpoints (to be implemented later).

## Functional Requirements
- Provide a REST endpoint (e.g. `POST /authz/clients/register`) for dynamic client registration that complies with OAuth 2.0 DCR specs and MCP guidance.
- Support baseline registration metadata fields: `client_name`, `redirect_uris`, `grant_types`, `token_endpoint_auth_method`, `scope`, and `contacts`.
- Require `grant_types` to include both `authorization_code` and `refresh_token`, ensuring the registered client is configured for code + refresh token issuance per MCP.
- Enforce PKCE support by validating `code_challenge_method` metadata and rejecting clients that do not commit to PKCE for public flows.
- Generate and return unique `client_id` and `client_secret` (when applicable) using secure random utilities.
- Persist registered clients in the database with all relevant metadata and timestamps.
- Reject invalid or insecure configurations (e.g. missing redirect URIs for public clients, unsupported grant types, insecure auth methods) with descriptive error payloads.
- Ensure idempotent handling where repeated submissions with the same metadata do not create duplicate clients if the specification requires conflict detection.
- Prepare for future management operations (read/update/delete) without exposing them yet.

## Technical Requirements
- Create a new backend module `authorization-server` with a nested `client-registration` submodule to isolate future token/authorization logic.
- Define database entity, repository, service, controller, and DTOs for client registration, leveraging decorators, validation pipes, and error handling patterns documented in the guides.
- Store client secrets using secure hashing/encryption utilities aligned with the security guidance in the docs (add helpers if missing).
- Use transactions or unit-of-work patterns when persisting client metadata and related records.
- Include comprehensive request validation, response DTOs, and OpenAPI/Swagger documentation.
- Add migrations or schema definition updates ensuring repeatable database setup.
- Cover business logic with unit tests (service-level) and request validation/integration tests (controller-level) following the testing practices described in the service/controller how-to guides.
- Provide configuration knobs (env vars) for toggling DCR availability, default secret length requirements, and other tunables that future authorization flows may need.

## Non-Functional Requirements
- Adhere to logging, error handling, and security hardening recommendations in `docs/best-practices`.
- Document the module in `docs/` as needed, including onboarding notes for the new submodule.
- Ensure the endpoint is rate-limit friendly and ready for future API gateway integration.
